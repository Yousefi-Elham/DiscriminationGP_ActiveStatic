library(numDeriv)

sigma2.ini=1
theta1=1
theta2=1.07

x1 <- seq(0,10,length.out = 25)
x2 <- seq(0,10,length.out = 25)
grid <- expand.grid(x1,x2)
N <- nrow(grid)

set.seed(123)
actin=sample(1:N,4)
#grid[actin,]

n1 <- length(actin)
xstart <- grid[actin,]
xstart

des <- xstart
sigma2 <- sigma2.ini



DisM


nu <- 5/2
theta <- theta2


crit.fun.old <- function(nu,theta,sigma2,des){
  
  
  n <- nrow(des)
  DisM <- as.matrix(dist(des))
  
  
  h <-  sqrt(2*nu)*DisM*theta 
  partial.h <- sqrt(2*nu)*DisM
  
  
  kernel.nu <- sigma2*2^(1-nu)/gamma(nu)*h^(nu)*besselK(h,nu) #compare with kernel2
  diag(kernel.nu) <- 1
  
  
  partial.theta <- -sigma2*2^(1-nu)/gamma(nu)*h^nu*besselK(h,nu-1)*partial.h
  diag(partial.theta) <- 0 
  
  
  bessel.fun <- function(ka){
    B <- besselK(sqrt(2*ka)*DisM*theta,ka)
    return(B)
  }
  bessel.par <- jacobian(func=bessel.fun, x=nu, method="Richardson")
  bessel.par.mat <- matrix(bessel.par,n,n)
  diag(bessel.par.mat) <- 0
  
  
  logh.half <- log(h/2)
  diag(logh.half) <- 0 
  
  
  partial.nu <- sigma2*2^(1-nu)/gamma(nu)*h^nu *( ((logh.half + 1) - digamma(nu))*besselK(h,nu) + bessel.par.mat )
  diag(partial.nu) <- 0
  
  
  if(det(kernel.nu)<=0){
    Ds.crit <- 0
  }else{
    
    kernelnu.inv <- solve(kernel.nu)
    
    kernel.inv_th <- kernelnu.inv%*%partial.theta
    kernel.inv_nu <- kernelnu.inv%*%partial.nu
    
    
    FIM <- matrix(nrow = 2, ncol = 2)
    FIM[1,1] <- 0.5 * sum(t(kernel.inv_th)*kernel.inv_th) # double derivative for theta
    FIM[2,2] <- 0.5 * sum(t(kernel.inv_nu)*kernel.inv_nu) # double derivative for nu
    FIM[1,2] <- FIM[2,1] <- 0.5 * sum(t(kernel.inv_th)*kernel.inv_nu) # cross derivative between theta and nu
    
    Ds.crit <- det(FIM)/FIM[1,1]
    
  }
  
  return(Ds.crit)
  
}

crit.fun.old(5/2,1.07)
#-------------------------------------------------
kernel.inv.fun <- function(nu,theta, sigma2, des) {
  
  n <- nrow(des)
  DisM <- as.matrix(dist(des))
  
  
  h <-  sqrt(2*nu)*DisM*theta 
  partial.h <- sqrt(2*nu)*DisM
  
  
  kernel.nu <- sigma2*2^(1-nu)/gamma(nu)*h^(nu)*besselK(h,nu) #compare with kernel2
  diag(kernel.nu) <- 1
  
  #kernel1 <- sigma2*(1 + sqrt(3)*DisM*theta[1]) * exp(-sqrt(3)*DisM*theta[1])
  #kernel2 <- sigma2*(1 + sqrt(5)*DisM*theta[2] + 5*DisM^2*theta[2]^2/3 ) * exp(-sqrt(5)*DisM*theta[2])
  
  if(det(kernel.nu)==0){
    
    kernel.inv <- NULL
    
  } else {
    kernel.inv <- solve(kernel.nu)
    #kernel.n <- kernel.nu
    
  }	
  
  return(list(kernel.inv = kernel.inv))
}
#-------------------------------------------------
crit.fun <- function(nu,theta,sigma2,des,cov.past.inv){
  
  
  n <- nrow(des)
  DisVec <- sqrt( (des[1:(n-1),1]-des[n,1])^2 + (des[1:(n-1),2]-des[n,2])^2 )
  
  
  h.vec <-  sqrt(2*nu)*DisVec*theta 
  partial.h.vec <- sqrt(2*nu)*DisVec
  
  
  #kernel.nu <- sigma2*2^(1-nu)/gamma(nu)*h^(nu)*besselK(h,nu) #compare with kernel2
  #diag(kernel.nu) <- 1
  
  cov.past.new <- sigma2*2^(1-nu)/gamma(nu)*h.vec^(nu)*besselK(h.vec,nu)

  
  kernel.n <- kernel.inv <- matrix(0,n,n)
  kernel.n[1:(n-1),1:(n-1)] <- cov.past
  kernel.n[n,1:(n-1)] <- kernel.n[1:(n-1),n] <- cov.past.new
  kernel.n[n,n] <- sigma2
  diag(kernel.n) <- 1
  
  Sinv.s12 <- cov.past.inv %*% cov.past.new
  B <- drop(sigma2 - cov.past.new %*% Sinv.s12)
  kernel.inv[1:(n-1),1:(n-1)] <- cov.past.inv+ 1/B * Sinv.s12 %*% t(Sinv.s12)
  kernel.inv[n,1:(n-1)] <- kernel.inv[1:(n-1),n] <- -1/B*Sinv.s12
  kernel.inv[n,n] <- 1/B
  
  #----------------
  DisM <- as.matrix(dist(des))
  
  
  h <-  sqrt(2*nu)*DisM*theta 
  partial.h <- sqrt(2*nu)*DisM
  
  
  #kernel.nu <- sigma2*2^(1-nu)/gamma(nu)*h^(nu)*besselK(h,nu) #compare with kernel2
  #diag(kernel.nu) <- 1
  
  
  partial.theta <- -sigma2*2^(1-nu)/gamma(nu)*h^nu*besselK(h,nu-1)*partial.h
  diag(partial.theta) <- 0 
  
  
  bessel.fun <- function(ka){
    B <- besselK(sqrt(2*ka)*DisM*theta,ka)
    return(B)
  }
  bessel.par <- jacobian(func=bessel.fun, x=nu, method="Richardson")
  bessel.par.mat <- matrix(bessel.par,n,n)
  diag(bessel.par.mat) <- 0
  
  
  logh.half <- log(h/2)
  diag(logh.half) <- 0 
  
  
  partial.nu <- sigma2*2^(1-nu)/gamma(nu)*h^nu *( ((logh.half + 1) - digamma(nu))*besselK(h,nu) + bessel.par.mat )
  diag(partial.nu) <- 0
  
  
  if(det(kernel.nu)<=0){
    Ds.crit <- 0
  }else{
    
    #kernelnu.inv <- solve(kernel.nu)
    kernelnu.inv <- kernel.inv
    
    kernel.inv_th <- kernelnu.inv%*%partial.theta
    kernel.inv_nu <- kernelnu.inv%*%partial.nu
    
    
    FIM <- matrix(nrow = 2, ncol = 2)
    FIM[1,1] <- 0.5 * sum(t(kernel.inv_th)*kernel.inv_th) # double derivative for theta
    FIM[2,2] <- 0.5 * sum(t(kernel.inv_nu)*kernel.inv_nu) # double derivative for nu
    FIM[1,2] <- FIM[2,1] <- 0.5 * sum(t(kernel.inv_th)*kernel.inv_nu) # cross derivative between theta and nu
    
    Ds.crit <- det(FIM)/FIM[1,1]
    
  }
  
  return(Ds.crit)
  
}
