
#Distance based


library(mvtnorm)
rm(list=ls())
par(mfrow=c(1,1))

####################################################################################
sigma2.ini=1
theta1=1
theta2=1.07 ##NEW par
est.theta <- c(theta1,theta2)

NRUN <- 100
nexc <- 200 # size of sequential design
x1 <- seq(0,10,length.out = 25)
x2 <- seq(0,10,length.out = 25)
grid <- expand.grid(x1,x2)
N <- nrow(grid)

actin=c(1,25,601,625)
#grid[actin,]

n1 <- length(actin)
xstart <- grid[actin,]
xstart
xcan <- grid[-actin,]
nleft <- nexc-n1


theta <- est.theta
sigma2 <- 1
des <- xstart
#--------------------------------------------------------------------------------------

  
n <- nrow(des)

DisM <- as.matrix(dist(des))
    
kernel1 <- sigma2*(1 + sqrt(3)*DisM*theta[1]) * exp(-sqrt(3)*DisM*theta[1])
kernel2 <- sigma2*(1 + sqrt(5)*DisM*theta[2] + 5*DisM^2*theta[2]^2/3 ) * exp(-sqrt(5)*DisM*theta[2])
    
K01 <- kernel1+kernel2
      
BayesL.p1 <- -n/2 -1/2*log( 1/2*det(2*kernel1)^(-1/2) + 1/2*det(K01)^(-1/2) )
BayesL.p2 <-      -1/2*log( 1/2*det(2*kernel2)^(-1/2) + 1/2*det(K01)^(-1/2) ) -1/4*log(det(kernel1)) -1/4*log(det(kernel2))
BayesL <- BayesL.p1 + BayesL.p2
BayesL  
  
  
#----------------------------
#Alternative formulation

p1 <- -n/2*(1+log(2*pi)) -1/4*log(det(kernel1)) -1/4*log(det(kernel2))
p2 <- -1/2*log( 1/2*dmvnorm(x=rep(0,n),sigma =2*kernel1)+1/2*dmvnorm(x=rep(0,n),sigma =K01) )
p3 <- -1/2*log( 1/2*dmvnorm(x=rep(0,n),sigma =2*kernel2)+1/2*dmvnorm(x=rep(0,n),sigma =K01) )
alt.BayesL <- p1+p2+p3
alt.BayesL

all.equal(BayesL,alt.BayesL) 
